KEY MARKING CRITERIA: 
// input vector format: [1.0 0.0 0.0] [0.0 1.0 0.0] [0.0 0.0 1.0] 
// always the same number of vectors as dimensions 
// program should parse arguments, infer dimension and solve 
// create a text file 'result.txt' with one number in it  

tasks: 
fix reduce so that it is correct for orthogonal bases 
fix reduce and listsieve so that no vector appears twice 
try to generalise the above 

write LLL 
test. 

void gramSchmidt(double **V, double **U, int dim) {
    for (int i = 0; i < dim; i++) {
        for (int k = 0; k < dim; k++) {
            U[i][k] = V[i][k];
        }
        for (int j = 0; j < i; j++) {
            double dotProduct = 0.0;
            for (int k = 0; k < dim; k++) {
                dotProduct += U[j][k] * V[i][k];
            }
            for (int k = 0; k < dim; k++) {
                U[i][k] -= (dotProduct / (U[j][k] * U[j][k])) * U[j][k];
            }
        }
        double norm = 0.0;
        for (int k = 0; k < dim; k++) {
            norm += U[i][k] * U[i][k];
        }
        norm = sqrt(norm);
        for (int k = 0; k < dim; k++) {
            U[i][k] /= norm;
        }
    }
}
change vec_diff so that it does not allocate any memory 
make changes to listsieve, common, reduce 

intitial p input 
find delta*lenP
for i in L 
    allocate 
    p - L[i]
    len(p - L[i])
    if len < lenP
        copy (p - L[i]) to p
        free 
    else 
        free 

initial input p 
delta*lenP

double* reduce(double* p, double** L, double delta, long int nSamples) {
    double len_p = delta * L2_norm(p);
    // Loop through the vectors in L to reduce p
    for (int i = 0; i < nSamples; i++) {
        double* diff = vec_diff(p, L[i]);
        double len = L2_norm(diff);
        if ((len <= len_p) && (len != 0)) {
            memcpy(p, diff, sizeof(double));
            free(diff);
            diff = NULL;
        }
        free(diff);
        diff = NULL;
    }
    return p;
}
